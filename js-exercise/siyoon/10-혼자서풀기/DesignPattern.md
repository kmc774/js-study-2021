디자인 패턴의 종류
+ 생성패턴(Creational Patterns): 객체 생성에 관련된 패턴입니다. 
  객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공합니다.
  1. 싱글톤 패턴(Singleton): 클래스의 인스턴스가 하나임을 보장하고 접근할 수 있는 전역적인 접근점을 제공하는 패턴
  2. 추상팩토리 패턴(Abstract Factory): 구체적인 클래스를 지정하지 않고 관련성이 있거나, 독립적인 객체들을 생성하기 위한 인터페이스를 제공하는 패턴
  3. 빌더 패턴(Builder): 복합 객체의 생성과정과 표현과정을 분리시켜 동일한 생성과정에서 다양한 표현을 생성할 수 있는 패턴
  4. 팩토리 메서드 패턴(Factory Method): 객체를 생성하는 인터페이스를 정의하지만, 인스턴스를 만드는 클래스는 서브클래스에서 결정하도록하는 패턴 팩토리 메서드에서는 인스턴스를 만드는 것을 서브 클래스에서 하게 됩니다. 
  5. 원형 패턴(Prototype): 생성할 객체의 종류를 명시하는데 원형이 되는 예시물을 이용하고 새로운 객체들이 원형들을 복사함으로써 생성하는 패턴입니다.

+ 구조 패턴(Structural Patterns): 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴입니다. 서로 다른 인터페이스를 지닌 2개의 객체를 묶어
  단일 인터페이스를 제공하거나 서로 다른 객체들을 묶어 새로운 기능을 제공하는 패턴입니다.
  1. 적응자 패턴(Adaptor or Wrapper): 클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴, 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 해주는 패턴
  2. 브리지 패턴(Bridge): 구현부에 추상층을 분리하여 각자 독립적으로 변형할 수 있도록 하는 패턴  
  3. 컴포지트 패턴(Composite): 객체들의 관계를 트리 구조로 구성하여 부분 천체 계층을 표현하는 패턴, 사용자가 단일/복합객체 모두 동일하게 다루도록하는 패턴
  4. 데코레이터 패턴(Decorator): 주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴, 기능 확장이 필요할 떄 서브클래스 대신 쓸 수 있는 대안이 될 수 있음
  5. 퍼사드 패턴(Facade): 서브시스템에 있는 인터페이스 집합에 통합된 하나의 인터페이스를 제공합니다. 서브시스템을 좀 더 쉽게 사용하기 위해 고수준의 인터페이스를 정의합니다.
  6. 프록시 패턴(Proxy): 어떤 다른 객체로 접근하는 것을 통제하기 위해 그 객체의 매니저 또는 자리 채움자를 제공하는 패턴
    

+ 행위 패턴(Behavioral Patterns): 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴입니다, 한 객체가 혼자 수행할 수 없는 작업을
  여러개의 객체로 어떻게 분배하는지, 또 객체 사이의 결합도를 최소화하는것에 중점을 두는 방식입니다.
  1. 옵저버 패턴(Observer): 객체들 사이에 1:N의 의존관계를 정의하여 어떤 객체의 상태가 변할 때, 의존 관계에 있는 모든 객체들이 통지받고 자동으로 갱신될 수 있게 만드는 패턴
  2. 상태 패턴(State): 객체의 내부 상태가 변경될 때 행동을 변경하도록 허락합니다. 객체는 자신의 클래스가 변경되는 것처럼 보이게 됩니다.
  3. 스트레이트지 패턴(Strategy): 동일 계열의 알고리즘들을 정의하고 각각 캡슐화하며 이들을 상호교환 가능하도록 만드는 것입니다. 알고리즘을 사용하는 사용자로부터 독립적으로 알고리즘이 변경될 수 있도록 하는 패턴
  4. 템플릿 패턴(Template): 객체의 연산에서 알고리즘의 뼈대만 정의하고 나머지는 서브클래스에서 이루어지게 하는 패턴입니다. 템플릿 패턴은 알고리즘의 구조는 변경하지 않고 알고리즘의 각 단계를 서브클래스에서 재정의하게 됩니다.
  5. 비지터 패턴(Visitor): 객체구조를 이루는 원소에 대해 수행할 연산을 표현. 방문자는 연산에 적용할 원소의 클래스를 변경하지 않고 새로운 연산을 재정의 할 수 있습니다.
  6. 역할 사슬 패턴(Chain of Responsibility): 요청을 처리하는 기회를 하나 이상의 객체에 부여하여 요청을 보내는 쪽과 받는 쪽의 결합을 피하는 패턴입니다. 요청을 받는 객체를 연쇄적으로 묶고 객체를 처리할 수 있을 때까지 요청을 전달
  7. 커맨드 패턴(Command): 요청을 객체로 캡슐화 하여 서로 다른 사용자의 매개변수화 요청 저장 또는 로깅 연산의 취소를 지원하게 만드는 패턴 
  8. 인터프리터 패턴(Interpreter): 주어진 언어에 대해서 문법을 위한 표현수단을 정의하고, 해당 언어로 된 문장을 해석하는 해석기를 사용하는 패턴
  9. 이터레이터 패턴(Iterator): 내부 표현부를 노출하지 않고 어떤 객체 집합의 원소들을 순차적으로 접근할 수 있는 방법을 제공하는 패턴
  10. 미디에이터 패턴(Mediator): 한 집합에 속해있는 객체들의 상호 작용을 캡슐화하는 객체를 정의하는 패턴 중재자는 객체들이 직접 서로 참조하지 않도록 함으로써 객체들간의 느슨한 연결을 촉진시키며 객체들의 상호작용을 독립적으로 다양화 시킬 수 있도록 해줍니다.

/*
- 소프트웨어 디자인 패턴에서 싱글턴 패턴을 따르는 클래스는, 생성자가 여러차례 호출되더라도 실제로 생성되는 객체는 하나이고
  최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다. 이와같은 디자인 유형을 싱글턴 패턴이라고 한다.
  주로 공통된 객체를 여러개 생성해서 사용하는 DBCP(DataBase Connection Pool)와 같은 상황에서 많이 사용된다.

- 어떤 클래스가 최초 한 번만 메모리를 할당(static)하고 해당 메모리에 인스턴스를 만들어 사용하는 패턴
- 인스턴스가 필요할 때 똑같은 인스턴스를 만들지 않고 기존의 인스턴스를 활용하는 것

장점 - 메모리 낭비 방지
- 싱글톤으로 만들어진 클래스와 다른 클래스의 인스턴스들의 데이터 공유가 쉽다
- 싱글톤 객체를 사용하지 않는 경우 인스턴스를 생성하지 않는다
- 싱글톤을 상속시킬 수 있다

단점 - 전역변수보다 사용하기 불편하다
- 싱글톤의 역할이 커질수록 결합도가 높아져 객체지향 설계 원칙에 어긋날 수 있다
- 멀티쓰레드 환경에서 컨트롤이 어렵다
- 객체의 파과 시점을 컨트롤하기 어려울 수 있따
*/
  
여러번 사용할 때 에러방지
카운트 할 때 강제로 인스턴스가 생기지 못하게 할 때
하나만 있어야 할 때

디자인패턴

데코레이터패턴.
전략패턴.
상태패턴.
프로토타입패턴.
프록시패턴.
옵저버패턴.
싱글톤패턴.
--------------------------------

생성패턴
- 싱글톤패턴
- 프로토타입패턴(원형패턴): 원형이 되는 인스턴스로 새로운 인스턴스를 만드는 방식,
객체에 의해 생성될 객체의 타입이 결정되는 생성 디자인 패턴
Prototype 자신을 복제하는데 필요한 인터페이스를 정의
ConcretePrototype 복제하는 연산을 구현
Client 프로토 타입에 자기 자신의 복제를 요청하여 새로운 객체 생성
객체의 생성이 값비싼 경우(DB 참조하는 등) 객체 생성의 비용을 줄일 수 있습니다.


구조패턴
- 데코레이터패턴: 객체의 결합을 통해 기능을 동적으로 유연하게 확장 할 수 있게 해주는 패턴
기본 기능에 추가할 수 있는 기능의 종류가 많은 경우에 각 추가 기능을 
Decorator 클래스로 정의 한 후 필요한 Decorator 객체를 조합함으로써
추가 기능의 조합을 설계하는 방식
기본 기능에 추가할 수 있는 많은 종류의 부가 기능에서 파생되는 다양한 조합을
동적으로 구현할 수 있는 패턴

- 프록시패턴: 어떤 객체에 대한 접근을 제어하기 위한 용도로 대리인이나 대변인에 해당하는 객체를 제공하는 패턴

행위패턴
- 옵저버패턴
- 상태패턴: 어떤 행위를 수행할 때 상태에 행위를 수행하도록 위임
시스템의 각 상태를 클래스로 분리해 표현
각 클래스에서 수행하는 행위들을 메서드로 구현
외부로부터 캡슐화하기 위해 인터페이스를 생성하여 시스템의 각 상태를 나타내는 클래스로 실체화
상태를 객체화 하여 상태가 행동할 수 있도록 위임 (블로그)

- 전략패턴: 알고리즘군을 정의하고 각각을 캡슐화하여 교환해서 사용할 수 있도록 만드는 방식,
알고리즘을 사용하는 클라이언트와는 독립적으로 알고리즘을 변경할 수 있다.
알고리즘의 API 부분만 규정해서 변경해서 사용할 수 있도록 하는 것
전략을 쉽게 바꿀 수 있도록 해주는 디자인 패턴
-위임이라는 느슨한 연결을 사용하고 있으므로 알고리즘을 용이하게 교환 할 수 있음



- 이터레이터(반복자) 패턴
    - 정의
        + 컬렉션 구현 방법을 노출시키지 않으면서 그 집합체 안에 들어있는 모든 항목에 접근할 수 있는 방법을 제공한다.
        + 복잡 객체의 원소를 순차적으로 접근 가능하게 해주는 행위패턴
        + 많이 모여있는 것들을 순서대로 지정하면서 전체를 검색하는 처리를 실행하기 위한 패턴
        
    - 사용 목적 
        + 내부 구현을 노출 시키지 않고 집합 객체에 접근하고 싶은 경우
        + 집합 객체에 다양한 탐색 경로가 필요한 경우 (iterator 인터페이스 상속 구조) 역방향 탐색, 특정 인덱스 탐색 등
        
    - 장점 
        + 집합 객체의 다양한 순회 방법을 제공
        + 집합 객체에 따라 하나 이상의 순회 방법이 제공 된다.
        
    - 단점
        + 순회 알고리즘 구현 부분에 따라서 캡슐화 전략을 위배 할 수도 있다.
        + 사용자가 직접 반복자를 삭제하는 책임을 가져야 한다.


- 미디에이터(중재자) 패턴
    - 정의
        + 모든 클래스간의 복잡한 로직을 캡슐화하여 하나의 클래스에 위임하여 처리하는 패턴
        + M:N의 관계에서 M:1의 관계로 복잡도를 떨어뜨려 유지 보수 및 재사용의 확장성에 유리한 패턴
        + 서로 다른 객체간에 상호 통신이 매우 복잡할 때 중재자를 통해 객체간의 통신을 가능하도록 캡슐화 하는 방법
        + 두 객체를 직접 연결하지 않고 제 3의 객체를 통해 느슨하게 연결하는 것
       
    - 사용 목적
        + 객체들간 커뮤니케이션 정의가 잘 되어있으나 복잡할 때 사용한다. 
        + 서로 상호작용하는 object들을 캡슐화함으로써 loose coupling을 유지하게 위해 사용한다.
    
    - 장점
        + 효율적인 자원관리(리소스 풀 등)가 가능
        + 객체간의 통신을 위해 서로간에 직접 참조할 필요가 없게 한다.
        + 중재자 구현 클래스는 추후에 더 효율적인 클래스로 변경될 수 있다.
        + 전체적인 연결관계를 이해하기 쉽다.
        
    - 단점
        + 객체간의 통신 로직이 복잡해지거나 객체의 형태가 자주 변경되는 경우 유지보수, 관리가 어렵다.
        + 특정 application 로직에 맞춰져있기 때문에 다른 application에 재사용하기 힘들다.
        
    - 차이점
        + 옵저버 패턴은 subscriber가 받기만 하는데 미디에이터 패턴은 서로 통신 한다는 것에서 차이가 있음 
        + Observer 패턴:
            + '한 객체'의 이벤트를 여러 객체가 구독.
            + 하나의 객체에 변화가 생기면 다른 객체에서 그 상태 변화에 따라 업데이트.
            + 데이터(Subject)를 구독하는 여러 뷰 컴포넌트들(Observers)
        + Mediator 패턴:
            + '서로 다른 객체'의 이벤트를 서로 구독.
            + multi option selection 리스트 박스, text input, button으로 구성된 다이얼로그에서
            listBox.select() → textInput.update()
            textInput.update() → button.activate()
            이렇게 서로 다른 객체의 이벤트를 참조하는 경우
        