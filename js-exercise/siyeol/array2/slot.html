<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      //슬롯 클래스
      class Slot {
        constructor(inputAmount) {
          this._returnCoin = 0                                    // 당첨 금액
          this._winInfos = new Array()                             // 당첨된 슬롯 라인의 정보
          this._amount = inputAmount                              // 투입 금액
          this._matrix = Array.from(Array(3), () => new Array(3)) // 세팅된 슬롯
          this._shapeList = [                                     // 슬롯 모양 정보
            { shape: "star", score: 10 }
            , { shape: "square", score: 5 }
            , { shape: "circle", score: 3 }
            , { shape: "triangle", score: 2 }
          ]
        }

        start() { //슬롯 랜덤 세팅
          let maxIndex = Math.pow( this._matrix.length, 2 )                 //행, 열의 마지막 인덱스
          let randomVal = 0                                                 //랜덤 값이 저장될 변수
          for ( let column = 0; column < this._matrix.length; column++ ) {
            for( let row = 0; row < this._matrix[column].length; row++ ) {
              randomVal = this._shapeList[ parseInt(Math.random() * 4) ]    //0~3 랜덤값 생성
              this._matrix[column][row] = randomVal
            }
          }
        } // start[end]

        winCheck() {
          this._matrix.forEach( (item, idx) => {  //(callback 함수 안에서는 this를 사용할 수 없기 때문에 람다식 사용)
            let set_check = new Set(item)         //중복체크로 Set 객체 사용
            const result = {}                     //당첨된 matrix 인덱스 번호와 shape 정보를 저장 후 반환할 변수
            if ( set_check.size === 1 ) {
              result.idx = idx
              result.shapeInfo = item[0]
              this._winInfos.push(result)
            }
          })
        } // winCheck[end]

        output() {
          this.start()
          this.winCheck()
          
          // print
          this._matrix.forEach( (item, idx) => { 
            document.writeln('<div id="idx'+idx+'">')
            item.forEach( (item) => {
              document.writeln('<span>' + item.shape + '</span>')
            })
            document.write('</div>')
          })
          //paint
          this._winInfos.forEach( (item) => { 
            let taget = document.getElementById('idx'+item.idx)
            taget.style.color = "blue"
          })

          // result
          if (this._winInfos.length === 0) {
            document.writeln("실패")
          } else if (this._winInfos.length > 0) {
            document.writeln("성공")
            this._winInfos.forEach((item) => { //this는 callback함수에서 사용은 지양하지 때문에 람다식 사용
              this._returnCoin += item.shapeInfo.score * this._amount             
            })
            document.writeln("coin : ", this._returnCoin )
          }
        }// output[end]

      } // 클래스

      const slot = new Slot(3)
      slot.output()
    </script>
  </body>
</html>
